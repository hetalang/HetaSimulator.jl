#= 
    This code was generated by heta-compiler 0.9.5
=#

__platform__ = (function()

### create default constants
nameless_constants_num_ = NamedTuple{(
  :k1,:k2,:k3,
)}(Float64[
  0.001,0.0001,0.022,
])

### create default observables
nameless_records_output_ = NamedTuple{(
  :comp1,:comp2,:a,:b,:c,:d,:r1,:r2,
)}(Bool[
  false,false,true,true,true,false,false,false,
])

### create default events
nameless_events_active_ = NamedTuple{(
  :sw1,
)}(Bool[
  true,
])

### vector of non-steady-state
nameless_dynamic_nonss_ = NamedTuple{(
  :a,:b,:c,:d,
)}(Bool[
  true,true,true,true,
])

### initialization of ODE variables and Records
function nameless_init_func_(__constants__)
    # Heta initialize
    t = 0.0 # initial time
    comp1 = 1.1
    comp2 = 2.2
    a = 1e+1
    r1 = __constants__[1] * a
    b = 0e+0
    c = 1e+0
    d = 0e+0
    r2 = __constants__[2] * b * c - __constants__[3] * d
    
    # save results

    return (
        Float64[
            a * comp1,
            b * comp1,
            c * comp1,
            d * comp2,
        ],
        Float64[
            comp1,
            comp2,
            __constants__...
        ]
    )
end

### calculate RHS of ODE
function nameless_ode_func_(__du__, __u__, __p__, t)
    (comp1,comp2,) = __p__.x[1]
    __constants__ = __p__.x[2]
    (a_,b_,c_,d_,) = __u__ 

    # Heta rules
    a = a_ / comp1
    r1 = __constants__[1] * a
    b = b_ / comp1
    c = c_ / comp1
    d = d_ / comp2
    r2 = __constants__[2] * b * c - __constants__[3] * d
    
    #__p__.x[1] .= [comp1,comp2,]
    __du__ .= [
      -r1,  # da_/dt
      r1-r2,  # db_/dt
      -r2,  # dc_/dt
      r2,  # dd_/dt
    ]
end

### output function
# XXX: currently force amounts: s1_, s2_ are not supported
function nameless_saving_generator_(__outputIds__::Vector{Symbol})
    __wrongIds__ = setdiff(__outputIds__, [:comp1,:comp2,:a,:b,:c,:d,:r1,:r2,])
    !isempty(__wrongIds__) && throw("The following observables have not been found in the model's Records: $(__wrongIds__)")

    __out_expr__ = Expr(:block)
    [push!(__out_expr__.args, :(__out__[$i] = $obs)) for (i,obs) in enumerate(__outputIds__)]

    @eval function(__out__, __u__, t, __integrator__)
        (comp1,comp2,) = __integrator__.p.x[1]
        __constants__ = __integrator__.p.x[2]
        (a_,b_,c_,d_,) = __u__

        # Heta rules
        a = a_ / comp1
        r1 = __constants__[1] * a
        b = b_ / comp1
        c = c_ / comp1
        d = d_ / comp2
        r2 = __constants__[2] * b * c - __constants__[3] * d
        
        # force amount

        $(__out_expr__)
        return nothing
    end
end

### TIME EVENTS ###
function nameless_sw1_tstops_func_(__constants__, __times__)
    return [50.0]
end

### D EVENTS ###

### C EVENTS ###

### STOP EVENTS ###

### event assignments
function nameless_sw1_affect_func_(__integrator__)
    t = __integrator__.t
    (comp1,comp2,) = __integrator__.p.x[1]
    __constants__ = __integrator__.p.x[2]
    (a_,b_,c_,d_,) = __integrator__.u

    # Heta rules
    a = a_ / comp1
    
    # recalculated values
    (a,) = (a + 1e+0,)
    
    # save results
    __integrator__.u[[1,]] = [
        a*comp1,
    ]
    __integrator__.p[[]] = [
    ]
end


### MODELS ###

nameless_model_ = (
  nameless_init_func_,
  nameless_ode_func_,
  NamedTuple{(
    :sw1,
  )}([
    (nameless_sw1_tstops_func_, nameless_sw1_affect_func_, false),
  ]),
  NamedTuple{(
  )}([
  ]),
  NamedTuple{(
  )}([
  ]),
  NamedTuple{(
  )}([
  ]),
  nameless_saving_generator_,
  nameless_constants_num_,
  nameless_events_active_,
  nameless_records_output_,
  nameless_dynamic_nonss_
)

### OUTPUT ###

return (
  (
    nameless = nameless_model_,
  ),
  (),
  "0.9.5"
)

end
)()